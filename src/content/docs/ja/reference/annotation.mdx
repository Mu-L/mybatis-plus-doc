---
title: アノテーション設定
sidebar:
  order: 2
---
import { LinkCard } from '@astrojs/starlight/components';
import Badge from "@/components/Badge.astro";

本文では、MyBatisPlus アノテーションの使用方法と属性について詳細に説明し、より深く理解するためのソースコードリンクを提供します。以下のリンクからアノテーションクラスのソースコードを確認できます。

<LinkCard
  title="MyBatis-Plus アノテーション ソースコード"
  description="ソースコードには比較的完全なコメントが含まれており、ソースコードを確認して機能を理解することができます。"
  href="https://github.com/baomidou/mybatis-plus/tree/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation"
/>

## @TableName

このアノテーションは、エンティティクラスが対応するデータベーステーブル名を指定するために使用されます。エンティティクラス名とデータベーステーブル名が一致しない場合、またはエンティティクラス名がデータベーステーブル名のキャメルケース表記ではない場合、このアノテーションを使用して明示的にテーブル名を指定する必要があります。

```java {1}
@TableName("sys_user")
public class User {
    private Long id;
    private String name;
    private Integer age;
    private String email;
}
```

### value

<p>
    **タイプ：** `String` <br/>
    **デフォルト値：** `""`
</p>

エンティティクラスに対応するデータベーステーブル名を指定します。エンティティクラス名とテーブル名が一致しない場合、この属性を使用して正しいテーブル名を指定します。

### schema

<p>
    **タイプ：** `String` <br/>
    **デフォルト値：** `""`
</p>

データベースのスキーマ名を指定します。通常、データベースがスキーマを使用してテーブルを整理していない場合、このプロパティは空のままにしておくことができます。

### keepGlobalPrefix

<p>
    **タイプ：** `boolean` <br/>
    **デフォルト値：** `false`
</p>

グローバル設定で tablePrefix が設定されている場合、このプロパティはグローバルのテーブルプレフィックスを維持するかどうかを決定します。true に設定すると、アノテーションでテーブル名が指定されている場合でも、自動的にグローバルのテーブルプレフィックスが付加されます。

### resultMap

<p>
    **タイプ：** `String` <br/>
    **デフォルト値：** `""`
</p>

XML で定義された ResultMap の ID を指定します。この ResultMap は、クエリ結果を特定の型のエンティティクラスオブジェクトにマッピングするために使用されます。

### autoResultMap

<p>
    **タイプ：** `boolean` <br/>
    **デフォルト値：** `false`
</p>

ResultMap を自動的に構築するかどうかを設定します。すでに resultMap が設定されている場合、この属性は適用されません。

:::note
MyBatis-Plus は自動的に resultMap を構築し、MyBatis に注入します。ただし、注入が完了すると、生成される内容は静的なものとなり、XML 設定での内容と同様になります。resultMap に関連する操作を使用する際は、typeHandler の処理に注意してください。

MyBatis が typeHandler の記述をサポートしているのは、以下の2箇所のみです：

- resultMap 内で定義し、クエリ結果のマッピングに作用させる。
- insert および update 文の `#{property}` 内の property の後ろに定義します（例：`#{property,typehandler=xxx.xxx.xxx}`）。これは、設定された現在の値にのみ作用します。

上記2つの typeHandler を直接指定する形式以外に、MyBatis にはカスタム typeHandler パッケージをグローバルにスキャンする設定があります。これは、プロパティの型に基づいて対応する typeHandler を検索し使用するという仕組みです。
:::

### excludeProperty

<p>
    **タイプ：** `String[]` <br/>
    **デフォルト値：** `{}` <br/>
    **追加バージョン：** <Badge text="@since 3.3.1" vertical="middle"/>
</p>

マッピング時に除外するプロパティ名を指定します。これらのプロパティは生成される SQL 文に含まれません。

## @TableId

このアノテーションは、エンティティクラス内の主キーフィールドをマークするために使用されます。主キーフィールドの名前が id の場合、このアノテーションは省略できます。

```java {3}
@TableName("sys_user")
public class User {
    @TableId
    private Long id;
    private String name;
    private Integer age;
    private String email;
}
```

### value

<p>
    **タイプ：** `String` <br/>
    **デフォルト値：** `""`
</p>

データベーステーブルの主キーフィールド名を指定します。設定しない場合、MyBatis-Plusはエンティティクラスのフィールド名をデータベーステーブルの主キーフィールド名として使用します。

### type

<p>
    **タイプ：** `Enum` <br/>
    **デフォルト値：** `IdType.NONE`
</p>

主キーの生成戦略を指定します。

**IdType 列挙型の定義**

- `IdType.AUTO`：データベースの自動増分IDを主キーとして使用します。
- `IdType.NONE`：特定の生成戦略はありません。グローバル設定にIdType関連の設定がある場合は、グローバル設定に従います。
- `IdType.INPUT`：データ挿入前に、ユーザーが自身で主キーの値を設定します。
- `IdType.ASSIGN_ID`：`ID`を自動的に割り当てます。`Long`、`Integer`、`String` タイプの主キーに適用されます。デフォルトでは、雪花アルゴリズムを利用し、`IdentifierGenerator` の `nextId` メソッドを通じて実装されます。<Badge text="@since 3.3.0"/>
- `IdType.ASSIGN_UUID`：`UUID`を自動的に割り当てます。`String` タイプの主キーに適用されます。デフォルトの実装は `IdentifierGenerator` の `nextUUID` メソッドです。<Badge text="@since 3.3.0"/>

:::note
非推奨となったIDタイプ（`ID_WORKER`、`UUID`、`ID_WORKER_STR`など）は使用を避け、代わりに `ASSIGN_ID` または `ASSIGN_UUID` を使用してください。これらの新しい戦略は、より優れた柔軟性と互換性を提供します。
:::

## @TableField

このアノテーションは、エンティティクラス内の非主キーフィールドをマークするために使用されます。MyBatis-Plusに対して、エンティティクラスのフィールドをデータベーステーブルのフィールドにどのようにマッピングするかを指示します。エンティティクラスのフィールド名がキャメルケースの命名規則に従っており、かつデータベーステーブルのフィールド名と一致する場合、このアノテーションは省略できます。

```java {5}
@TableName("sys_user")
public class User {
    @TableId
    private Long id;
    @TableField("nickname") // データベースフィールド "nickname" にマッピング
    private String name;
    private Integer age;
    private String email;
}
```

### value

<p>
    **タイプ:** `String`<br/>
    **デフォルト値:** `""`
</p>
データベース内のフィールド名を指定します。エンティティクラスのフィールド名とデータベースのフィールド名が異なる場合、この属性を使用して正しいデータベースフィールド名を指定します。

### exist

<p>
    **タイプ：** `boolean`<br/>
    **デフォルト値：** `true`
</p>
このフィールドがデータベーステーブルに存在するかどうかを示します。false に設定すると、MyBatis-Plus は SQL 生成時にこのフィールドを無視します。

### condition

<p>
    **タイプ：** `String`<br/>
    **デフォルト値：** `""`
</p>
エンティティクエリ（EntityQuery）を実行する際に、フィールドの条件式を指定します。これにより、WHERE 句におけるフィールドの比較方法をカスタマイズできます。この項目に値が設定されている場合は設定された値が使用され、値がない場合はグローバルなデフォルト値 `%s=#{%s}` が使用されます。

詳細な記述方法は [SqlCondition](https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/SqlCondition.java) を参照してください。

:::note[EntityQuery の説明]
EntityQuery とは、クエリ条件を構築する際に、SQL フラグメントを手動で記述するのではなく、エンティティクラスのフィールドを直接使用してクエリ条件を設定することを指します。
:::

**サンプル説明**

id、name、age の3つのフィールドを持つ User エンティティクラスがあると仮定します。年齢が18歳より大きいすべてのユーザーを検索したい場合、QueryWrapper を使用してこのクエリを構築し、User エンティティクラスのインスタンスを直接渡すことができます：

```java
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.SqlCondition;

// エンティティクラス定義
@TableName("sys_user")
public class User {
    @TableId
    private Long id;

    private String name;

    @TableField(condition = "%s > #{%s}") // age フィールドの条件式をカスタマイズ
    private Integer age;

    private String email;
}

// EntityQuery を使用してクエリを構築
public List<User> findUserAgeOver18() {
    // クエリ条件を設定するための User インスタンスを作成
    User queryEntity = new User();
    queryEntity.setAge(18); // age フィールドの値を設定

    // QueryWrapper インスタンスを作成し、User インスタンスを渡す
    QueryWrapper<User> queryWrapper = new QueryWrapper<>(queryEntity);

    // クエリを実行
    List<User> userList = userMapper.selectList(queryWrapper);

    return userList;
}
```

この例では、`@TableField(condition = "%s > #{%s}")` アノテーションを使用して age フィールドにカスタムの条件式を設定しています。クエリを構築する際に、User インスタンスを作成し、age フィールドの値を18に設定しました。その後、このインスタンスを使用して QueryWrapper を作成すると、MyBatis-Plus はエンティティクラスのアノテーションに基づいて適切な SQL クエリ条件を自動生成します。

findUserAgeOver18 メソッドを実行すると、MyBatis-Plus は以下のような SQL 文を生成します：

```sql
SELECT * FROM sys_user WHERE age > 18;
```

この方法により、condition プロパティはクエリ時のフィールドの動作をカスタマイズすることができ、特定のニーズに合わせたより柔軟なクエリを可能にし、SQL フラグメントを手動で記述する煩わしさを回避できます。

### update

<p>
    **タイプ:** `String`<br/>
    **デフォルト値:** `""`
</p>
更新操作を実行する際に、SET句におけるフィールドの式を指定します。この属性はel属性よりも優先度が高く、フィールドの更新ロジックをカスタマイズすることができます。

**サンプル説明**

Userエンティティクラスにversionフィールドが含まれており、ユーザー情報を更新するたびにversionフィールドの値を自動的に1増加させたい場合を想定します。この機能を実現するために、@TableFieldアノテーションのupdate属性を使用できます：

```java
import com.baomidou.mybatisplus.annotation.TableField;

@TableName("sys_user")
public class User {
    @TableId
    private Long id;

    private String name;

    private Integer age;

    private String email;

    @TableField(update="%s+1") // 更新時の式をカスタマイズ
    private Integer version;
}
```

この例では、`@TableField(update="%s+1")`アノテーションがMyBatis-Plusに、更新操作を実行する際にversionフィールドに対して`version = version + 1`の式を使用するように指示します。これにより、ユーザー情報を更新するたびに、versionフィールドの値が自動的に1増加します。

以下の更新操作を実行した場合：

```java
User user = new User();
user.setId(1L);
user.setName("Updated Name");
user.setAge(30);
user.setEmail("updated@example.com");

userMapper.updateById(user);
```

MyBatis-Plusは以下のようなSQL文を自動生成します：

```sql
UPDATE sys_user
SET name = 'Updated Name', age = 30, email = 'updated@example.com', version = version + 1
WHERE id = 1;
```

この方法により、update属性を使用して更新時のフィールドの動作をカスタマイズでき、更新操作をより柔軟に、特定の要件に合わせて調整することができます。また、SQLフラグメントを手動で記述する煩雑さを回避できます。

### insertStrategy

<p>
    **タイプ：** `Enum`<br/>
    **デフォルト値：** `FieldStrategy.DEFAULT`
</p>

新しいレコードを挿入する際に、フィールドの値をどのように処理するかを定義します。このプロパティを使用して、フィールドを INSERT 文に含めるかどうか、およびどのような条件下で含めるかを制御できます。

**[FieldStrategy](https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/FieldStrategy.java) 列挙型定義**

- FieldStrategy.DEFAULT：グローバル設定の戦略に従います。グローバル設定で指定されていない場合、デフォルトの動作はフィールド値が NULL でない場合にのみそのフィールドを挿入します。
- FieldStrategy.ALWAYS：フィールド値が NULL かどうかに関わらず、常にそのフィールドを挿入します。
- FieldStrategy.NOT_NULL：フィールド値が NULL でない場合にのみ、そのフィールドを挿入します。
- FieldStrategy.NOT_EMPTY：フィールド値が空でない（文字列型の場合）または NULL でない（その他の型の場合）場合にのみ、そのフィールドを挿入します。
- FieldStrategy.NEVER：フィールド値が NULL でない場合でも、そのフィールドを挿入しません。
- FieldStrategy.IGNORED： 判定を無視し、効果は "ALWAYS" と同じです <Badge text="@Deprecated" type="error"/>

**サンプル説明**

User エンティティクラスに nickname フィールドが含まれており、新しいユーザーを挿入する際に、nickname が空でない場合にのみそのフィールドを挿入したいとします。この機能を実現するには、@TableField アノテーションの insertStrategy プロパティを使用できます：

```java
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.FieldStrategy;

@TableName("sys_user")
public class User {
    @TableId
    private Long id;

    @TableField(insertStrategy = FieldStrategy.NOT_EMPTY) // nickname が空でない場合のみ挿入
    private String nickname;

    private Integer age;

    private String email;
}
```

この例では、`@TableField(insertStrategy = FieldStrategy.NOT_EMPTY)` アノテーションが MyBatis-Plus に、新しいユーザーを挿入する際に nickname フィールドが空でない場合にのみ INSERT 文に含めるように指示します。

以下の挿入操作を実行した場合：

```java
User user = new User();
user.setNickname("John Doe");
user.setAge(25);
user.setEmail("john.doe@example.com");

userMapper.insert(user);
```

MyBatis-Plus は自動的におおよそ以下のような SQL 文を生成します：

```sql
INSERT INTO sys_user (nickname, age, email)
VALUES ('John Doe', 25, 'john.doe@example.com');
```

nickname フィールドが空の場合、生成される SQL は nickname フィールドを含みません：

```sql
INSERT INTO sys_user (age, email)
VALUES (25, 'john.doe@example.com');
```

この効果は、以下のような MyBatis のカスタム XML 設定と同等です：

```xml
<mapper namespace="com.example.mapper.UserMapper">

    <!-- ユーザーを挿入 -->
    <insert id="insertUser" parameterType="com.example.entity.User">
        INSERT INTO sys_user (
            <if test="nickname != null and nickname != ''">
                nickname,
            </if>
            age,
            email
        ) VALUES (
            <if test="nickname != null and nickname != ''">
                #{nickname},
            </if>
            #{age},
            #{email}
        )
    </insert>

</mapper>
```

この方法により、insertStrategy プロパティは挿入時のフィールドの動作をカスタマイズできるようにし、挿入操作をより柔軟にし、特定の要件に合わせることができます。同時に、手動で SQL フラグメントを記述する煩雑さを回避できます。

### updateStrategy

<p>
    **タイプ:** `Enum`<br/>
    **デフォルト値:** `FieldStrategy.DEFAULT`
</p>
レコード更新時に、フィールドの値をどのように処理するかを定義します。このプロパティを使用して、UPDATE 文の SET 句にフィールドを含めるかどうか、またどのような条件で含めるかを制御できます。

FieldStrategy 列挙型の詳細については、insertStrategy プロパティを参照してください。

**サンプル説明**

User エンティティクラスに nickname フィールドが含まれており、ユーザー情報を更新する際に、値が空かどうかに関係なく常に nickname フィールドを更新したいとします。この機能を実現するには、@TableField アノテーションの updateStrategy プロパティを使用します：

```java
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.FieldStrategy;

@TableName("sys_user")
public class User {
    @TableId
    private Long id;

    @TableField(updateStrategy = FieldStrategy.ALWAYS) // 常に nickname を更新し、値のチェックを無視します
    private String nickname;

    private Integer age;

    private String email;
}
```

この例では、`@TableField(updateStrategy = FieldStrategy.ALWAYS)` アノテーションが MyBatis-Plus に、ユーザー情報を更新する際に常に nickname フィールドを UPDATE 文の SET 句に含め、その値のチェックを無視するように指示します。

以下の更新操作を実行した場合：

```java
User user = new User();
user.setId(1L);
user.setNickname("Updated Nickname");
user.setAge(30);
user.setEmail("updated@example.com");

userMapper.updateById(user);
```

MyBatis-Plus は自動的におおよそ以下のような SQL 文を生成します：

```sql
UPDATE sys_user
SET nickname = 'Updated Nickname', age = 30, email = 'updated@example.com'
WHERE id = 1;
```

nickname フィールドの値が空かどうかに関係なく、生成される SQL には nickname フィールドが含まれます。つまり、nickname フィールドの値が空の場合でも、生成される SQL は nickname フィールドを NULL に更新します。

このように、updateStrategy プロパティを使用することで、更新時のフィールドの動作をカスタマイズでき、更新操作をより柔軟にし、特定の要件に合わせることができます。同時に、手動で SQL フラグメントを記述する煩わしさを回避できます。

### whereStrategy

<p>
    **タイプ:** `Enum`<br/>
    **デフォルト値:** `FieldStrategy.DEFAULT`
</p>
更新ステートメントの WHERE 句を生成する際に、フィールドの値をどのように処理するかを定義します。このプロパティにより、フィールドを WHERE 句に含めるかどうか、またどのような条件下で含めるかを制御できます。

FieldStrategy 列挙型の詳細については、insertStrategy および updateStrategy プロパティを参照してください。

**例による説明**

User エンティティクラスに nickname フィールドが含まれており、ユーザー情報を更新する際に、nickname フィールドが空でない場合のみ WHERE 句の条件として使用したいとします。この機能を実現するには、@TableField アノテーションの whereStrategy プロパティを使用します：

```java
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.FieldStrategy;

@TableName("sys_user")
public class User {
    @TableId
    private Long id;

    @TableField(whereStrategy = FieldStrategy.NOT_EMPTY) // nickname が空でない場合のみ WHERE 条件として使用
    private String nickname;

    private Integer age;

    private String email;
}
```

この例では、`@TableField(whereStrategy = FieldStrategy.NOT_EMPTY)` アノテーションが MyBatis-Plus に、whereEntity を使用して更新ステートメントの WHERE 句を生成する際に、nickname フィールドが空でない場合のみ WHERE 句に含めるように指示します。

以下の更新操作を実行する場合：

```java
User user = new User();
user.setEmail("john.doe@example.com");

User whereEntity = new User();
whereEntity.setNickname("John Doe");
whereEntity.setAge(30);

// whereEntity メソッドを使用
UpdateWrapper<User> updateWrapper = new UpdateWrapper<>(whereEntity);
userMapper.update(user, updateWrapper);
```

MyBatis-Plus は自動的に以下のような SQL ステートメントを生成します：

```sql
UPDATE sys_user
SET email = 'john.doe@example.com'
WHERE nickname = 'John Doe' AND age = 30;
```

nickname フィールドが空の場合、生成される SQL には nickname フィールドが含まれません：

```sql
UPDATE sys_user
SET email = 'john.doe@example.com'
WHERE age = 30;
```

この効果は、以下の MyBatis のカスタム XML 設定と同等です：

```xml
<mapper namespace="com.example.mapper.UserMapper">

    <!-- ユーザー情報を更新 -->
    <update id="updateUser" parameterType="com.example.entity.User">
        UPDATE sys_user
        SET email = #{email}
        <where>
            <if test="nickname != null and nickname != ''">
                AND nickname = #{nickname}
            </if>
            AND age = #{age}
        </where>
    </update>
    
</mapper>
```

このように、whereStrategy プロパティを使用することで、WHERE 句におけるフィールドの動作をカスタマイズでき、更新操作をより柔軟に、特定の要件に合わせて行うことができます。同時に、手動で SQL フラグメントを記述する煩雑さを回避できます。FieldStrategy 列挙型の詳細については、insertStrategy および updateStrategy プロパティを参照してください。

### fill

<p>
    **タイプ:** `Enum`<br/>
    **デフォルト値:** `FieldFill.DEFAULT`
</p>
フィールド自動フィル戦略。このプロパティは、データベース操作（挿入、更新など）を実行する際に、フィールドの値をどのように自動的に埋めるかを指定するために使用されます。FieldFill 列挙型を使用することで、フィールドのフィル動作を柔軟に制御できます。

:::note
この機能は、[自動フィルフィールド](/guides/auto-fill-field)機能と組み合わせて使用する必要があります。
:::

**[FieldFill](https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/FieldFill.java) 列挙型定義**

- `FieldFill.DEFAULT`：デフォルトではフィルを行わず、データベースのデフォルト値または手動設定に依存します。

- `FieldFill.INSERT`：挿入操作時にフィールド値を自動的に埋めます。

- `FieldFill.UPDATE`：更新操作時にフィールド値を自動的に埋めます。

- `FieldFill.INSERT_UPDATE`：挿入操作と更新操作の両方でフィールド値を自動的に埋めます。

**サンプル説明**

User エンティティクラスがあり、createTime フィールドと updateTime フィールドが含まれていると仮定します。ユーザー作成時に作成日時を自動的に埋め、ユーザー情報更新時に更新日時を自動的に埋めたいとします。

```java
import com.baomidou.mybatisplus.annotation.FieldFill;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableName;
import java.time.LocalDateTime;

@TableName("user")
public class User {
    // 他のフィールド...

    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;

    @TableField(fill = FieldFill.UPDATE)
    private LocalDateTime updateTime;

    // コンストラクタ、getter、setter...
}
```

このサンプルでは、createTime フィールドは挿入操作時に現在時刻が自動的に埋められ、updateTime フィールドは更新操作時に現在時刻が自動的に埋められます。これにより、データベース操作のたびにこれらの時刻フィールドの値を手動で設定する必要がなくなります。

**ご注意ください**、自動フィル機能を正常に動作させるには、MyBatis-Plus の設定で対応する自動フィルハンドラを設定する必要があり、エンティティクラスに対応する Mapper インターフェースで対応する挿入メソッドと更新メソッドが定義されていることを確認する必要があります。

### select

<p>
    **タイプ:** `boolean`<br/>
    **デフォルト値:** `true`
</p>
クエリ操作を実行する際に、このフィールドを SELECT 文に含めるかどうかを指定します。この属性により、クエリ結果に含まれるフィールドを制御し、よりきめ細かいデータアクセス制御を提供できます。

**詳細説明**

- select 属性が true（デフォルト値）に設定されている場合、このフィールドはクエリ結果に含まれます。

- select 属性が false に設定されている場合、このフィールドがデータベーステーブルに存在していても、クエリ結果には含まれません。これは、機密データを保護したり、クエリのパフォーマンスを最適化したりする場合に有用です。

**使用例**

User エンティティクラスに password フィールドが含まれており、ユーザーのプライバシーを保護するためにユーザー情報をクエリする際にパスワードフィールドを除外したいとします。

```java
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableName;

@TableName("user")
public class User {
    // その他のフィールド...

    @TableField(select = false)
    private String password;

    // コンストラクタ、getter、setter...
}
```

この例では、クエリ操作を実行する際、password フィールドは SELECT 文に含まれないため、クエリ結果には現れません。このようにして、データベースにパスワード情報が保存されていても、通常のクエリで漏洩することはありません。

@TableField アノテーションの select 属性は、MyBatis-Plus が生成するクエリ文にのみ影響し、他のフレームワークや手動で記述された SQL 文には影響しないことに注意してください。さらに、select = false を使用したフィールドの場合、カスタムクエリや他の方法でそのフィールドにアクセスする際には、データのセキュリティと完全性に特に注意する必要があります。

### keepGlobalFormat

<p>
    **タイプ：** `boolean`<br/>
    **デフォルト値：** `false`
</p>
フィールド処理時に、グローバル DbConfig で定義された columnFormat ルールを保持するかどうかを示します。このプロパティは、データベース操作においてフィールド値にグローバルな列フォーマットルールを適用するかどうかを制御するために使用されます。

### jdbcType

<p>
    **タイプ：** `JdbcType`<br/>
    **デフォルト値：** `JdbcType.UNDEFINED`
</p>
JDBCタイプ。フィールドのデータベースにおけるデータ型を指定するために使用されます。このプロパティを使用すると、フィールドのデータベース型を明示的に設定でき、特に特殊な型やカスタム型を扱う場合にデータベースとの互換性を確保できます。

**詳細説明**

- jdbcType プロパティが JdbcType.UNDEFINED（デフォルト値）に設定されている場合、MyBatis-Plus はフィールドの Java 型に基づいてその JDBC 型を自動的に推論します。

- jdbcType プロパティが特定の JdbcType 列挙値に設定されている場合、そのフィールドは指定された JDBC 型を使用してデータベース操作が実行されます。これは、型マッピングの問題を解決するため、またはデータベース型を精密に制御する必要がある場合に使用できます。

**例示**

カスタム型 `MyCustomType` のフィールドを含む CustomType エンティティクラスがあると仮定します。このフィールドを特定の JDBC 型でデータベースに保存したい場合、以下のように設定します。

```java
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableName;
import org.apache.ibatis.type.JdbcType;

@TableName("custom_type")
public class CustomType {
    // 他のフィールド...

    @TableField(value = "my_custom_field", jdbcType = JdbcType.VARCHAR)
    private MyCustomType myCustomField;

    // コンストラクタ、getter、setter...
}
```

この例では、`myCustomField` フィールドは VARCHAR JDBC 型を使用してデータベース操作が行われます。これにより、`MyCustomType` がカスタム型であったとしても、VARCHAR 型に変換されてデータベースに保存されます。

**ご注意ください**、jdbcType プロパティは、Java 型とデータベース型の間に不明確なマッピング関係が存在する場合など、特定の状況でのみ設定する必要があります。ほとんどの場合、MyBatis-Plus は型マッピングを自動的に処理するため、jdbcType を明示的に設定する必要はありません。また、jdbcType プロパティは MyBatis-Plus が生成する SQL ステートメントにのみ影響し、他のフレームワークや手動で記述された SQL ステートメントには影響しません。

### typeHandler

<p>
    **タイプ：** `Class<? extends TypeHandler>`<br/>
    **デフォルト値：** `UnknownTypeHandler.class`
</p>
型ハンドラは、データベース操作において特定のフィールドの値をどのように処理するかを指定するために使用されます。このプロパティを使用すると、特定のデータ型やビジネスニーズに合わせて、フィールド値の変換ロジックをカスタマイズできます。

**詳細説明**

- typeHandler プロパティが設定されていない場合（つまりデフォルト値の UnknownTypeHandler.class を使用する場合）、MyBatis-Plus はデフォルトの型ハンドラを使用してフィールド値を処理します。

- typeHandler プロパティが特定の TypeHandler サブクラスに設定されている場合、そのフィールドは指定された型ハンドラを使用してデータベース操作が行われます。これは、カスタムタイプ、特殊なデータ形式、または非標準のデータベースタイプを処理するために使用できます。

**使用例**

User エンティティクラスに birthDate フィールドがあり、特定の形式でデータベースに日付を保存するカスタムの型ハンドラを使用して日付形式を処理したいと仮定します。

```java
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableName;
import com.example.myproject.typehandler.CustomDateTypeHandler;
import java.time.LocalDate;

@TableName("user")
public class User {
    // 他のフィールド...

    @TableField(value = "birth_date", typeHandler = CustomDateTypeHandler.class)
    private LocalDate birthDate;

    // コンストラクタ、getter、setter...
}
```

この例では、birthDate フィールドは CustomDateTypeHandler 型ハンドラを使用してデータベース操作が行われます。これにより、クエリ時にデータベースの日付値を LocalDate オブジェクトに変換する場合でも、更新時に LocalDate オブジェクトの日付値をデータベースの特定の日付形式に変換する場合でも、CustomDateTypeHandler を使用して処理されます。

CustomDateTypeHandler は次のように実装される可能性があります：

```java
import org.apache.ibatis.type.BaseTypeHandler;
import org.apache.ibatis.type.JdbcType;
import java.sql.CallableStatement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

public class CustomDateTypeHandler extends BaseTypeHandler<LocalDate> {
    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd");

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, LocalDate parameter, JdbcType jdbcType) throws SQLException {
        ps.setString(i, parameter.format(FORMATTER));
    }

    @Override
    public LocalDate getNullableResult(ResultSet rs, String columnName) throws SQLException {
        String dateString = rs.getString(columnName);
        return (dateString != null) ? LocalDate.parse(dateString, FORMATTER) : null;
    }

    // 他の必要なメソッドを実装...
}
```

このカスタム型ハンドラでは、日付の形式を指定する DateTimeFormatter を定義し、setNonNullParameter および getNullableResult メソッドで日付値の変換ロジックを実装しています。

**ご注意ください**、カスタム型ハンドラを有効にするには、MyBatis-Plus の設定で正しく登録され、実行時にロードできることを確認する必要があります。また、カスタム型ハンドラの使用は慎重に行い、正確性とパフォーマンスを確保してください。詳細については、[フィールド型ハンドラ](/guides/type-handler) の内容を参照してください。

### numericScale

<p>
    **タイプ:** `String`<br/>
    **デフォルト値:** `""`
</p>
小数点以下に保持する桁数を指定します。この属性は update 操作を実行する場合にのみ有効です。数値型フィールドの更新時の小数点精度を制御するために使用されます。

**詳細説明**

- numericScale 属性が空の文字列（デフォルト値）に設定されている場合、フィールドの小数点精度はデータベースのデフォルト設定、またはフィールド定義時の設定に従います。
- numericScale 属性が特定の数値（例: "2"）に設定されている場合、そのフィールドは update 操作実行時に指定された小数点桁数で処理されます。

**例による説明**
Product エンティティクラスに price フィールドが含まれており、価格を更新する際に小数点以下2桁を保持することを保証したいと仮定します。

```java
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableName;

@TableName("product")
public class Product {
    // その他のフィールド...

    @TableField(value = "price", numericScale = "2")
    private BigDecimal price;

    // コンストラクタ、getter、setter...
}
```

この例では、price フィールドは update 操作実行時に小数点以下2桁を保持することが保証されます。これは、価格を更新する際に、渡された価格値の小数点以下の桁数に関係なく、常に2桁の小数にフォーマットされることを意味します。

**ご注意ください**、numericScale 属性を有効にするには、データベースが指定された小数点桁数をサポートしていること、および update 操作実行時に渡される数値型フィールド値が正しく処理されることを確認する必要があります。さらに、numericScale 属性は MyBatis-Plus が生成する SQL ステートメントにのみ影響し、他のフレームワークや手動で記述された SQL ステートメントには影響しません。

:::note[numericScale、jdbcType、typeHandler に関する説明]

- numericScale 属性は update 操作時のみ有効です。
- jdbcType 属性および typeHandler 属性は、@TableName の autoResultMap = true と一緒に使用しない場合、同様に update 操作時のみ有効です。
- typeHandler については、フィールドの型と設定される値の型が equals 関係にある場合、typeHandler が MyBatis にロードされていることを確認するだけでよく、アノテーションを使用する必要はありません。

:::

## @Version

このアノテーションは、エンティティクラス内のフィールドを楽観的ロックのバージョン番号フィールドとしてマークするために使用されます。楽観的ロックは、複数のトランザクションが互いに干渉することなく同時に進行できると仮定し、トランザクションのコミット時にのみ競合がないかをチェックする並行性制御メカニズムです。エンティティクラスで`@Version`アノテーションを使用することで、MyBatis-Plusは更新操作時に自動的にバージョン番号をチェックし、更新プロセス中にデータが他のトランザクションによって変更されていないことを保証します。

```java
@TableName("sys_user")
public class User {
    @TableId
    private Long id;
    @TableField("nickname") // データベースフィールド "nickname" にマッピング
    private String name;
    private Integer age;
    private String email;
    @Version // 楽観的ロックのバージョン番号フィールドとしてマーク
    private Integer version;
}
```

上記の例では、versionフィールドが楽観的ロックのバージョン番号としてマークされています。更新操作を実行する際、MyBatis-Plusはこのフィールドの値がデータベース内の値と一致するかどうかをチェックします。一致しない場合、データ読み取り後に他のトランザクションがデータを変更したことを意味し、この時点で楽観的ロック例外がスローされ、開発者に適切な処理を行うよう通知します。

@Versionアノテーションを使用することで、同時更新時のデータ不整合問題を効果的に防止し、システムの並行性能とデータ完全性を向上させることができます。開発者はバージョン番号チェックのコードを手動で記述する必要がなく、MyBatis-Plusがこのプロセスを自動的に処理します。

## @EnumValue

このアノテーションは、列挙型クラス内のフィールドをマークし、データベースに保存する列挙値を指定するために使用されます。エンティティクラスのフィールドが列挙型である場合、`@EnumValue` アノテーションを使用することで、MyBatis-Plusにデータベースに保存する列挙値のどのプロパティかを指示することができます。

```java
@TableName("sys_user")
public class User {
    @TableId
    private Long id;
    @TableField("nickname") // データベースフィールド "nickname" にマッピング
    private String name;
    private Integer age;
    private String email;
    private Gender gender; // Gender が列挙型であると仮定
}

public enum Gender {
    MALE("M", "男"),
    FEMALE("F", "女");

    private String code;
    private String description;

    Gender(String code, String description) {
        this.code = code;
        this.description = description;
    }

    @EnumValue // データベースに保存する列挙値を code に指定
    public String getCode() {
        return code;
    }
}
```

上記の例では、`Gender` 列挙型クラスの `code` フィールドが `@EnumValue` でマークされています。これは、`User` エンティティクラスの `gender` フィールドをデータベースに保存する際に、列挙定数自体ではなく、`Gender` 列挙型の `code` の値が保存されることを意味します。

`@EnumValue` アノテーションを使用することで、列挙型がデータベースに保存される方法を柔軟に制御でき、データベース内のデータをよりコンパクトで扱いやすくすることができます。同時に、データベースから列挙値を読み取る際の変換プロセスも簡素化されます。MyBatis-Plus は `@EnumValue` アノテーションの設定に基づいて、データベースの値を自動的に対応する列挙インスタンスに変換するためです。

## @TableLogic

このアノテーションは、エンティティクラスのフィールドを論理削除フィールドとしてマークするために使用されます。論理削除は、データベースから実際にレコードを削除するのではなく、レコードに削除済み状態であることをマークするデータ管理戦略です。`@TableLogic`アノテーションを使用することで、MyBatis-Plusはクエリ、更新、削除操作において論理削除フィールドの値を自動的に処理します。

```java
@TableName("sys_user")
public class User {
    @TableId
    private Long id;
    @TableField("nickname") // データベースフィールド "nickname" にマッピング
    private String name;
    private Integer age;
    private String email;
    @TableLogic(value = "0", delval = "1") // 論理削除フィールド
    private Integer deleted;
}
```

上記の例では、deletedフィールドが論理削除フィールドとしてマークされています。@TableLogicアノテーションのvalue属性は論理的に未削除の値を指定し（この例では0）、delval属性は論理削除の値を指定します（この例では1）。

クエリ操作を実行する際、MyBatis-Plusは論理削除としてマークされたレコードを自動的にフィルタリングし、削除されていないレコードのみを返します。更新操作を実行する際、更新操作によって論理削除フィールドの値が論理削除値に変更される場合、MyBatis-Plusは自動的にそのレコードを削除済みとしてマークします。削除操作を実行する際、MyBatis-Plusは物理的にレコードを削除するのではなく、論理削除フィールドの値を論理削除値に自動的に更新します。

@TableLogicアノテーションを使用することで、データの論理削除を実現でき、データの完全性とトレーサビリティを維持するのに役立ちます。同時に、物理削除操作がもたらす可能性のあるデータ損失リスクを回避できます。開発者は論理削除のコードを手動で記述する必要がなく、MyBatis-Plusがこのプロセスを自動的に処理します。

## @KeySequence

このアノテーションは、Oracleデータベースにおけるシーケンス（Sequence）の名前を指定し、エンティティクラスで主キー値を生成するために使用されます。Oracleデータベースでは、主キーは通常、他のデータベースのように自動増分フィールドを使用するのではなく、シーケンスを通じて生成されます。@KeySequenceアノテーションは、MyBatis-Plusに特定のシーケンスを使用して主キーを生成するように指示します。

```java
@TableName("sys_user")
@KeySequence("SEQ_USER_ID") // シーケンス名を "SEQ_USER_ID" に指定
public class User {
    @TableId(type = IdType.INPUT) // シーケンスを使用して主キーを生成
    private Long id;
    @TableField("nickname") // データベースフィールド "nickname" にマッピング
    private String name;
    private Integer age;
    private String email;
}
```

上記の例では、@KeySequenceアノテーションがエンティティクラスUserに適用され、シーケンス名が"SEQ_USER_ID"に指定されています。これは、新しいレコードを挿入する際に、MyBatis-Plusがこのシーケンスを使用してidフィールドの値を生成することを意味します。

@KeySequenceアノテーションのvalue属性はシーケンスの名前を指定するために使用され、dbType属性はデータベースのタイプを指定するために使用されます。dbTypeが指定されていない場合、MyBatis-Plusは注入されたIKeyGenerator実装をデフォルトで使用します。複数のIKeyGenerator実装がある場合は、dbTypeを指定する必要があります。

@KeySequenceアノテーションを使用することで、Oracleデータベースで主キー値が正しく生成されることを保証し、同時に主キー生成の設定プロセスを簡素化します。開発者はシーケンス値を取得するコードを手動で記述する必要がなく、MyBatis-Plusがこのプロセスを自動的に処理します。

## @InterceptorIgnore

このアノテーションは、`Mapper`の特定の`method`（`method`にアノテーションを付与）またはすべての`method`（`Mapper`にアノテーションを付与）の実行時に、特定のプラグイン（マルチテナントなど）を無視するかどうかを指定するために使用されます。

```java
// @InterceptorIgnore(tenantLine = "1") // マルチテナントインターセプターを無視
public interface UserMapper extends BaseMapper<User> {

    @InterceptorIgnore(tenantLine = "1") // マルチテナントインターセプターを無視
    List<User> selectUsers();
}
```

上記の例では、`selectUsers`メソッドの実行時に、マルチテナントインターセプターが無視されます。

MyBatis-Plusが提供するプラグインには、アノテーション内に対応する属性があります。例えば、マルチテナントプラグインは`tenantLine`属性に対応します。属性の値が"1"、"yes"、"on"の場合、対応するプラグインは無視されます。属性の値が"0"、"false"、"off"または空の場合、プラグインは正常に実行されます。

プラグインの使用方法の詳細については、[プラグイン主体](/plugins)を参照してください。

## @OrderBy

このアノテーションは、エンティティクラスのフィールドに対してクエリ実行時のデフォルトの並び順を指定するために使用されます。エンティティクラスのフィールドに `@OrderBy` アノテーションを使用することで、クエリ実行時に明示的なソート条件が指定されていない場合、MyBatis-Plus がアノテーションで定義されたソートルールに従って結果を返すことを保証します。

```java
@TableName("sys_user")
public class User {
    @TableId
    private Long id;
    @TableField("nickname") // データベースフィールド "nickname" にマッピング
    private String name;
    @OrderBy(asc = false, sort = 10) // デフォルトのソートを降順、優先度を10として指定
    private Integer age;
    private String email;
}
```

上記の例では、`age` フィールドが `@OrderBy` でマークされ、`asc` 属性が `false` に設定されています。これはデフォルトのソートが降順であることを意味します。`sort` 属性は `10` に設定されており、このソートルールの優先度を示しています。

`@OrderBy` アノテーションの `asc` 属性は、ソートが昇順かどうかを指定するために使用されます。`true` に設定すると昇順ソートを、`false` に設定すると降順ソートを意味します。`sort` 属性はソートルールの優先度を指定するために使用され、数字が小さいほど優先度が高く、つまり先に適用されます。

注意点として、`@OrderBy` アノテーションのソートルールの優先度は、クエリ時に Wrapper 条件クエリオブジェクトを介して明示的に指定されたソート条件よりも低くなります。Wrapper でソート条件が指定された場合、`@OrderBy` アノテーションで定義されたデフォルトのソートは上書きされます。

`@OrderBy` アノテーションを使用することで、コードを簡素化し、毎回のクエリで明示的にソート条件を指定する手間を省くことができます。同時に、デフォルトのソート方法を提供することで、コードの可読性と保守性の向上に役立ちます。
